import json
import struct
from base64 import b64encode, b64decode
from hashlib import sha3_256
from typing import Any

import requests
from cryptography.hazmat.primitives.asymmetric import ed25519
from dataclasses import dataclass


def json_encode(data: Any) -> bytes:
    for k, v in list(data.items()):
        if isinstance(v, bytes):
            data[k] = b64encode(v).decode()
    return json.dumps(data).encode()


def sign_data(privkey: ed25519.Ed25519PrivateKey, data: bytes) -> bytes:
    return privkey.sign(sha3_256(data).digest())


class Api:
    def __init__(self, ip: str) -> None:
        self.ip = ip
        self.session = requests.Session()

    def get_entries(self, start: int, end: int) -> list[bytes]:
        print(f'> GET /api/v1/get-entries?start={start}&end={end}')
        response = self.session.get(f'http://{self.ip}:3000/api/v1/get-entries?start={start}&end={end}')
        return [b64decode(leaf) for leaf in response.json()['leaves']]

    def get_entry_proof(self, index: int) -> bytes:
        print(f'> GET /api/v1/get-entry-and-proof?leaf_index={index}')
        response = self.session.get(f'http://{self.ip}:3000/api/v1/get-entry-and-proof?leaf_index={index}')
        return b64decode(response.json()['proof'])

    def add_entry(self, entry: Any) -> int:
        print(f'> POST /api/v1/add-entry')
        response = self.session.post(f'http://{self.ip}:3000/api/v1/add-entry', data=json_encode(entry))
        return response.json()['index']

    def sign_entry(self, entry: Any) -> bytes:
        print(f'> POST /api/v1/sign-entry')
        response = self.session.post(f'http://{self.ip}:3000/api/v1/sign-entry', data=json_encode(entry))
        return b64decode(response.json()['sot'])

    def get_sth(self) -> bytes:
        print(f'> GET /api/v1/get-sth')
        response = self.session.get(f'http://{self.ip}:3000/api/v1/get-sth')
        return b64decode(response.json()['sth'])

    def get_pubkey(self) -> bytes:
        print(f'> GET /api/v1/get-pubkey')
        response = self.session.get(f'http://{self.ip}:3000/api/v1/get-pubkey')
        return b64decode(response.json()['pubkey'])

    def claim_private(self, sot: bytes, claimed_leaf: bytes) -> str:
        print(f'> POST /api/v1/claim-private')
        response = self.session.post(f'http://{self.ip}:3001/api/v1/claim-private', data=json_encode({
            'sot': sot,
            'claimed_leaf': claimed_leaf
        }))
        print('Private claim result:', response, response.text)
        return response.json()['data']

    def claim_public(self, claiming_leaf: bytes, claimed_leaf: bytes, privkey: ed25519.Ed25519PrivateKey) -> str:
        signature = sign_data(privkey, TreeLeafProof.from_binary(claiming_leaf).leaf)
        print(f'> POST /api/v1/claim-public')
        response = self.session.post(f'http://{self.ip}:3001/api/v1/claim-public', data=json_encode({
            'claiming_leaf': claiming_leaf,
            'claimed_leaf': claimed_leaf,
            'claiming_leaf_signature': signature,
        }))
        print('Public claim result:', response, response.text)
        return response.json()['data'] if 'json' in response.headers.get('content-type') else response.text


def byte_slice(b: bytes) -> bytes:
    return struct.pack('>H', len(b)) + b


def read_byte_slice(b: bytes) -> tuple[bytes, bytes]:
    l, = struct.unpack('>H', b[:2])
    return b[2:2 + l], b[2 + l:]


def read_string(b: bytes) -> bytes:
    l = b[0]
    return b[1:1 + l]


@dataclass
class Sth:
    size: int
    timestamp: bytes
    hash: bytes
    signature: bytes

    @classmethod
    def from_binary(cls, b: bytes) -> 'Sth':
        return Sth(
            int.from_bytes(b[:8], byteorder='big'),
            b[8:8 + 15],
            b[8 + 15:8 + 15 + 32],
            b[8 + 15 + 32:]
        )

    def to_binary(self) -> bytes:
        return struct.pack('>Q', self.size) + \
            self.timestamp + \
            self.hash + \
            self.signature


@dataclass
class TreeLeaf:
    created: bytes
    contenthash: bytes
    name: bytes
    pubkey: bytes
    data_for_private_claims: bytes
    data_for_public_claims: bytes

    def to_binary(self) -> bytes:
        assert len(self.created) == 15
        assert len(self.contenthash) == 32
        return self.created + byte_slice(
            self.contenthash + struct.pack('>B', len(self.name)) + self.name
        ) + byte_slice(self.pubkey) + byte_slice(self.data_for_private_claims) + byte_slice(self.data_for_public_claims)

    @classmethod
    def from_binary(cls, data: bytes) -> 'TreeLeaf':
        ts = data[:15]
        owner, data = read_byte_slice(data[15:])
        pubkey, data = read_byte_slice(data)
        data_private, data = read_byte_slice(data)
        data_public, data = read_byte_slice(data)
        return TreeLeaf(
            ts,
            owner[:32],
            read_string(owner[32:]),
            pubkey,
            data_private,
            data_public
        )


@dataclass
class TreeLeafProof:
    head: Sth
    index: int
    leaf: bytes
    hashes: list[bytes]

    def to_binary(self) -> bytes:
        return byte_slice(self.head.to_binary()) + \
            struct.pack('>Q', self.index) + \
            byte_slice(self.leaf) + \
            struct.pack('>H', len(self.hashes)) + b''.join(self.hashes)

    @classmethod
    def from_binary(self, data: bytes) -> 'TreeLeafProof':
        head, data = read_byte_slice(data)
        index, = struct.unpack('>Q', data[:8])
        leaf, data = read_byte_slice(data[8:])
        hash_len, = struct.unpack('>H', data[:2])
        hashes = [data[2 + i * 32:2 + i * 32 + 32] for i in range(hash_len)]
        return TreeLeafProof(Sth.from_binary(head), index, leaf, hashes)
